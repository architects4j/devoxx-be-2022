{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this workshop The persistence mechanism is the heart of most applications and microservices, although architects often happen not to give as much attention to such components. A wrong choice and design, will impact the whole system's functioning, no matter how much you scale up the service. Join this session and learn how to avoid this from happening. In this guided lab, you'll learn tips and tricks on creating a healthier app with an increased performance by improving its relation with database persistence. From a Java perspective, you'll try not only more conventional options like SQL and NoSQL but also some trendy new solutions in the market like MicroStream. You'll also have hands-on experience with this open-source ultrafast in-memory data persistence storage allows queries to be up to 1000x times faster than traditional relational databases. About this workshop This workshop was built to- and delivered at- Devoxx Belgium 2022 , by Elias Nogueira , Karina Varela Ot\u00e1vio Santana . Check out more about the session at https://devoxx.be/talk/?id=20173 . References For information about the technologies covered in this workshop, check out the following items: Documentation : Microstream Microstream Docs Integration with CDI Jakarta NoSQL Jakarta Data Supported integrations Open Liberty Wildfly Payara Helidon","title":"About this workshop"},{"location":"#about-this-workshop","text":"The persistence mechanism is the heart of most applications and microservices, although architects often happen not to give as much attention to such components. A wrong choice and design, will impact the whole system's functioning, no matter how much you scale up the service. Join this session and learn how to avoid this from happening. In this guided lab, you'll learn tips and tricks on creating a healthier app with an increased performance by improving its relation with database persistence. From a Java perspective, you'll try not only more conventional options like SQL and NoSQL but also some trendy new solutions in the market like MicroStream. You'll also have hands-on experience with this open-source ultrafast in-memory data persistence storage allows queries to be up to 1000x times faster than traditional relational databases.","title":"About this workshop"},{"location":"#about-this-workshop_1","text":"This workshop was built to- and delivered at- Devoxx Belgium 2022 , by Elias Nogueira , Karina Varela Ot\u00e1vio Santana . Check out more about the session at https://devoxx.be/talk/?id=20173 .","title":"About this workshop"},{"location":"#references","text":"For information about the technologies covered in this workshop, check out the following items: Documentation : Microstream Microstream Docs Integration with CDI Jakarta NoSQL Jakarta Data Supported integrations Open Liberty Wildfly Payara Helidon","title":"References"},{"location":"00_environment/","text":"Preparing your environment Prerequisites Maven CLI; Git CLI; Java 11; An IDE of your preference; Command line (terminal). If using Windows, PowerShell is recommended; Helidon CLI (optional) ; REST client tools like cURL or postman (Optional) ; Tip The Helidon CLI can be used alternatively if you want to rely on features only available through this tool. To check if you have the above tools installed, open your terminal and running the following the commands. You should be able to see the version of each of the tools: java -version mvn -version git --version Installing helidon CLI (optional) To install Helidon, you can run the commands below according to your O.S: MacOS: curl -O https://helidon.io/cli/2.3.3/darwin/helidon chmod +x ./helidon sudo mv ./helidon /usr/local/bin/ Linux: curl -O https://helidon.io/cli/2.3.3/linux/helidon chmod +x ./helidon sudo mv ./helidon /usr/local/bin/ Windows: PowerShell -Command Invoke-WebRequest -Uri \"https://helidon.io/cli/2.3.3/windows/helidon.exe\" -OutFile \"C:\\Windows\\system32\\helidon.exe\" You can verify the installation by running in the terminal: helidon version Helidon CLI is available for Helidon 2+. Prepare your working directory To get started with the labs, first you need to clone the foundation project and have it available in your local development environment. Info The guided exercises are built on top of quickstart projects, a foundation set of preconfigured projects. To get the foundation projects and build them, execute: git clone https://github.com/architects4j/ #ToDo cd helidon-microstream-training-labs-foundation mvn clean package The build and packaging should complete successfully.","title":"Preparing your environment"},{"location":"00_environment/#preparing-your-environment","text":"","title":"Preparing your environment"},{"location":"00_environment/#prerequisites","text":"Maven CLI; Git CLI; Java 11; An IDE of your preference; Command line (terminal). If using Windows, PowerShell is recommended; Helidon CLI (optional) ; REST client tools like cURL or postman (Optional) ; Tip The Helidon CLI can be used alternatively if you want to rely on features only available through this tool. To check if you have the above tools installed, open your terminal and running the following the commands. You should be able to see the version of each of the tools: java -version mvn -version git --version","title":"Prerequisites"},{"location":"00_environment/#installing-helidon-cli-optional","text":"To install Helidon, you can run the commands below according to your O.S: MacOS: curl -O https://helidon.io/cli/2.3.3/darwin/helidon chmod +x ./helidon sudo mv ./helidon /usr/local/bin/ Linux: curl -O https://helidon.io/cli/2.3.3/linux/helidon chmod +x ./helidon sudo mv ./helidon /usr/local/bin/ Windows: PowerShell -Command Invoke-WebRequest -Uri \"https://helidon.io/cli/2.3.3/windows/helidon.exe\" -OutFile \"C:\\Windows\\system32\\helidon.exe\" You can verify the installation by running in the terminal: helidon version Helidon CLI is available for Helidon 2+.","title":"Installing helidon CLI (optional)"},{"location":"00_environment/#prepare-your-working-directory","text":"To get started with the labs, first you need to clone the foundation project and have it available in your local development environment. Info The guided exercises are built on top of quickstart projects, a foundation set of preconfigured projects. To get the foundation projects and build them, execute: git clone https://github.com/architects4j/ #ToDo cd helidon-microstream-training-labs-foundation mvn clean package The build and packaging should complete successfully.","title":"Prepare your working directory"},{"location":"01_getting_started_microstream/","text":"Delivering ultra-fast persistence with well-designed Java microservices Introduction What you will learn Here are the key learnings you will get with this hands-on exercise: Learn how Microprofile empowers Java developers to quickly build and deliver microservices. Info The exercises are built on Helidon as the runtime, although other MicroProfile runtimes can be used to implement the same examples. E.g. WildFly, Open Liberty, Payara. Explore the basic project structure of a MicroProfile-based Java microservice; Understand how architectural best practices allows the implementation decoupled code - domain logic and technical details are not tightened together; Learn how to add in-memory Java-native persistence; Know the capabilities that results from usage of specifications such as MicroProfile Config, CDI, JAX-RS and more; Experience the benefits of using a Java native persistence solution, such as easy data model mapping and manipulation; Pre requisites To be able to go through this guided exercise, you will need to have the following components in your dev environment: Have finished the steps described in Preparing your environment , especially the section Prepare-your-working-directory . Hands-on practice Getting started with MicroProfile Explore the project The projects have the following characteristics: Info Details MicroProfile Version 3.3 Build Tool Maven MicroProfile Runtime Helidon The project's structures are similar to: . \u251c\u2500\u2500 pom.xml \u251c\u2500\u2500 readme.md \u2514\u2500\u2500 src \u2514\u2500\u2500 main \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 org \u2502 \u2514\u2500\u2500 a4j \u2502 \u2514\u2500\u2500 ... ( packages and classes ) \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 META-INF \u2502 \u251c\u2500\u2500 beans.xml \u2502 \u2514\u2500\u2500 microprofile-config.properties \u2514\u2500\u2500 pom.xml Package and run Open the terminal and access the project's folder: devoxx-be-2022/workshop-foundation/microprofile/ Run the following maven command. Maven will download the dependencies described in the project's pom.xml file. It will also create an executable jar we can use to access our application: team.jar . mvn clean package Now, let's start the microservice. In the terminal, run the following command: java -jar target/team.jar If everything goes well, you should see an output similar to: bash 2022.10.11 02:34:00 INFO io.helidon.microprofile.server.ServerCdiExtension !thread!: Server started on http://localhost:8080 (and all other host addresses) in 2277 milliseconds (since JVM startup). 2022.10.11 02:34:00 INFO io.helidon.common.HelidonFeatures !thread!: Helidon MP 2.5.4 features:[CDI, Config, Fault Tolerance, Health, JAX-RS, Metrics, Open API, REST Client, Security, Server, Tracing] In your browser, access the page http://localhost:8080/data/hello What are the classes that are responding to this request? Now change the message that is displayed in this page to \"Hello Devoxx Belgium!!!\" . Tip In the class org.a4j.workshop.HelloController , you'll find a GET endpoint that prints the message you saw in your browser. If you update it, package and run the application you should see the changes reflected on the page. When using helidon CLI and the Dev Loop, you should be able to visualize the change without the extra effort of manually re-packaging and running the service. Package your application, start it again, and check the changes on the page. Tip Maven helps you packaging the application, and you can use the JDK installed locally to execute the generated file: mvn clean package java -jar target/team.jar Congratulations You've successfully created, packaged, changed and accessed an application based on the MicroProfile specification and that runs with the Helidon runtime! Going further There are several cool capabilities - such as native compilation and the Helidon dev loop - that you can further explore. To know more about these topics, refer to the Learn More page. MicroStream: using ultra-fast persistence The project contains a data model and the respective classes required to manipulate these data: * Data model: composed of the Player , Position and Team classes. * Service classes: the layer that holds business rules. The TeamService is part of it. * Endpoints: the REST API is exposed through the resource class, in this case, TeamResource . Feel free to explore these classes before moving forward. Add MicroStream to the project To add MicroStream as the persistence solution of this microservice, we must add it as a maven dependency, so it gets included as a library when this project is build. Open the pom.xml and add the following dependency: <dependency> <groupId> one.microstream </groupId> <artifactId> microstream-integrations-cdi </artifactId> <version> 07.00.00-MS-GA </version> </dependency> Next, we'll add Microstream's configuration. It relies on MicroProfile Config and has a very flexible and easy setup. Open src/main/resources/META-INF/microprofile-config.properties : one.microstream.storage.directory = target/data one.microstream.channel.count = 4 Tip The property one.microstream.storage.directory indicates the folder where any data will be persisted. Filesystem is the default persistent storage target, although, it is not recommended for production. To learn about other storage targets check out the MicroStream documentation Data mapping and storage configuration Entity configurations : Open the Player class. In the JPA world, this would be considered an entity bean and would be mapped with @Entity`. With MicroStream, there is no need to annotate classes and map them to an existing database. If we were using JPA, we would also have to set the @Id and @Column in the attributes of the class. Good news : nothing needs to be changed on the data model! Root and Storage: manipulating data gets very straightforward with MicroStream. The objects are serialized and saved in a graph structure, which means you don't have to worry with all the complex relations between classes. The key is to understand what is going to be your root node. In our scenario, we have a team of players. In this case, we do not want to allow the user to manipulate players as an independent model, instead, every player is part of a team - in other words, it belongs to an object graph in which the root is the team. Once you identify what is going to be the root class in your scenario, you then know which class you should configure with the @Storage annotation. Once you add the root node as a @Storage , CDI will take care of a lot of work under the covers. You won't have to deal with transaction managers, persistence context and so on. As of now, let's configure the Team class as our root : 4.1. Open the org.a4j.workshop.Team class, and annotate it with @Storage : @Storage public class Team { Next, you'll work on the methods that manipulates the data inside our service in-memory persistence storage. Data manipulation ---- wip refer to the comments in the code Methods that changes persisted data --- wip: @store in class teamservice Testing the service By default it will run on port 8081, as configured in the microprofile-config.properties . Check the service implementation with the following request examples: ----- wip: atualizar os requests Insert a new product List all products Search a product by ID (name) Update a product using its ID (name) Delete a product by ID (name) If you can successfully execute the above items, it means you acomplished this section's goals! Congratulations! You've finished your task! You have easily modified an existing project by taking advantadge of a well-defined persistence layer. You have used MicroStream to allow this service to persist its data using an ultra-fast in-memory solution. Well done!","title":"Delivering ultra-fast persistence with well-designed Java microservices"},{"location":"01_getting_started_microstream/#delivering-ultra-fast-persistence-with-well-designed-java-microservices","text":"","title":"Delivering ultra-fast persistence with well-designed Java microservices"},{"location":"01_getting_started_microstream/#introduction","text":"","title":"Introduction"},{"location":"01_getting_started_microstream/#what-you-will-learn","text":"Here are the key learnings you will get with this hands-on exercise: Learn how Microprofile empowers Java developers to quickly build and deliver microservices. Info The exercises are built on Helidon as the runtime, although other MicroProfile runtimes can be used to implement the same examples. E.g. WildFly, Open Liberty, Payara. Explore the basic project structure of a MicroProfile-based Java microservice; Understand how architectural best practices allows the implementation decoupled code - domain logic and technical details are not tightened together; Learn how to add in-memory Java-native persistence; Know the capabilities that results from usage of specifications such as MicroProfile Config, CDI, JAX-RS and more; Experience the benefits of using a Java native persistence solution, such as easy data model mapping and manipulation;","title":"What you will learn"},{"location":"01_getting_started_microstream/#pre-requisites","text":"To be able to go through this guided exercise, you will need to have the following components in your dev environment: Have finished the steps described in Preparing your environment , especially the section Prepare-your-working-directory .","title":"Pre requisites"},{"location":"01_getting_started_microstream/#hands-on-practice","text":"","title":"Hands-on practice"},{"location":"01_getting_started_microstream/#getting-started-with-microprofile","text":"","title":"Getting started with MicroProfile"},{"location":"01_getting_started_microstream/#explore-the-project","text":"The projects have the following characteristics: Info Details MicroProfile Version 3.3 Build Tool Maven MicroProfile Runtime Helidon The project's structures are similar to: . \u251c\u2500\u2500 pom.xml \u251c\u2500\u2500 readme.md \u2514\u2500\u2500 src \u2514\u2500\u2500 main \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 org \u2502 \u2514\u2500\u2500 a4j \u2502 \u2514\u2500\u2500 ... ( packages and classes ) \u2502 \u2514\u2500\u2500 resources \u2502 \u2514\u2500\u2500 META-INF \u2502 \u251c\u2500\u2500 beans.xml \u2502 \u2514\u2500\u2500 microprofile-config.properties \u2514\u2500\u2500 pom.xml","title":"Explore the project"},{"location":"01_getting_started_microstream/#package-and-run","text":"Open the terminal and access the project's folder: devoxx-be-2022/workshop-foundation/microprofile/ Run the following maven command. Maven will download the dependencies described in the project's pom.xml file. It will also create an executable jar we can use to access our application: team.jar . mvn clean package Now, let's start the microservice. In the terminal, run the following command: java -jar target/team.jar If everything goes well, you should see an output similar to: bash 2022.10.11 02:34:00 INFO io.helidon.microprofile.server.ServerCdiExtension !thread!: Server started on http://localhost:8080 (and all other host addresses) in 2277 milliseconds (since JVM startup). 2022.10.11 02:34:00 INFO io.helidon.common.HelidonFeatures !thread!: Helidon MP 2.5.4 features:[CDI, Config, Fault Tolerance, Health, JAX-RS, Metrics, Open API, REST Client, Security, Server, Tracing] In your browser, access the page http://localhost:8080/data/hello What are the classes that are responding to this request? Now change the message that is displayed in this page to \"Hello Devoxx Belgium!!!\" . Tip In the class org.a4j.workshop.HelloController , you'll find a GET endpoint that prints the message you saw in your browser. If you update it, package and run the application you should see the changes reflected on the page. When using helidon CLI and the Dev Loop, you should be able to visualize the change without the extra effort of manually re-packaging and running the service. Package your application, start it again, and check the changes on the page. Tip Maven helps you packaging the application, and you can use the JDK installed locally to execute the generated file: mvn clean package java -jar target/team.jar Congratulations You've successfully created, packaged, changed and accessed an application based on the MicroProfile specification and that runs with the Helidon runtime!","title":"Package and run"},{"location":"01_getting_started_microstream/#going-further","text":"There are several cool capabilities - such as native compilation and the Helidon dev loop - that you can further explore. To know more about these topics, refer to the Learn More page.","title":"Going further"},{"location":"01_getting_started_microstream/#microstream-using-ultra-fast-persistence","text":"The project contains a data model and the respective classes required to manipulate these data: * Data model: composed of the Player , Position and Team classes. * Service classes: the layer that holds business rules. The TeamService is part of it. * Endpoints: the REST API is exposed through the resource class, in this case, TeamResource . Feel free to explore these classes before moving forward.","title":"MicroStream: using ultra-fast persistence"},{"location":"01_getting_started_microstream/#add-microstream-to-the-project","text":"To add MicroStream as the persistence solution of this microservice, we must add it as a maven dependency, so it gets included as a library when this project is build. Open the pom.xml and add the following dependency: <dependency> <groupId> one.microstream </groupId> <artifactId> microstream-integrations-cdi </artifactId> <version> 07.00.00-MS-GA </version> </dependency> Next, we'll add Microstream's configuration. It relies on MicroProfile Config and has a very flexible and easy setup. Open src/main/resources/META-INF/microprofile-config.properties : one.microstream.storage.directory = target/data one.microstream.channel.count = 4 Tip The property one.microstream.storage.directory indicates the folder where any data will be persisted. Filesystem is the default persistent storage target, although, it is not recommended for production. To learn about other storage targets check out the MicroStream documentation","title":"Add MicroStream to the project"},{"location":"01_getting_started_microstream/#data-mapping-and-storage-configuration","text":"Entity configurations : Open the Player class. In the JPA world, this would be considered an entity bean and would be mapped with @Entity`. With MicroStream, there is no need to annotate classes and map them to an existing database. If we were using JPA, we would also have to set the @Id and @Column in the attributes of the class. Good news : nothing needs to be changed on the data model! Root and Storage: manipulating data gets very straightforward with MicroStream. The objects are serialized and saved in a graph structure, which means you don't have to worry with all the complex relations between classes. The key is to understand what is going to be your root node. In our scenario, we have a team of players. In this case, we do not want to allow the user to manipulate players as an independent model, instead, every player is part of a team - in other words, it belongs to an object graph in which the root is the team. Once you identify what is going to be the root class in your scenario, you then know which class you should configure with the @Storage annotation. Once you add the root node as a @Storage , CDI will take care of a lot of work under the covers. You won't have to deal with transaction managers, persistence context and so on. As of now, let's configure the Team class as our root : 4.1. Open the org.a4j.workshop.Team class, and annotate it with @Storage : @Storage public class Team { Next, you'll work on the methods that manipulates the data inside our service in-memory persistence storage.","title":"Data mapping and storage configuration"},{"location":"01_getting_started_microstream/#data-manipulation","text":"---- wip refer to the comments in the code","title":"Data manipulation"},{"location":"01_getting_started_microstream/#methods-that-changes-persisted-data","text":"--- wip: @store in class teamservice","title":"Methods that changes persisted data"},{"location":"01_getting_started_microstream/#testing-the-service","text":"By default it will run on port 8081, as configured in the microprofile-config.properties . Check the service implementation with the following request examples: ----- wip: atualizar os requests Insert a new product List all products Search a product by ID (name) Update a product using its ID (name) Delete a product by ID (name) If you can successfully execute the above items, it means you acomplished this section's goals! Congratulations! You've finished your task! You have easily modified an existing project by taking advantadge of a well-defined persistence layer. You have used MicroStream to allow this service to persist its data using an ultra-fast in-memory solution. Well done!","title":"Testing the service"},{"location":"02_nosql/","text":"NoSQL persistence on Java services ---- wip: update references to team In this exercise you can validate and practice your knowledge of the following concepts: Java microservice implementation with Helidon; Dev experience when using NoSQL databases with Java; Jakarta NoSQL; Implicit and constant usage of CDI; Getting familiar with the use case and the exercise goals described next is highly recommended, as a detailed step-by-step guide is not provided. Friendly advice : consider leveraging this opportunity to upskill by making the best use of your knowledge and research skills to code the solution without replicating the provided solution. Scenario Acme Store contacted you to ask for advise about NoSQL databases usage in MicroProfile-based services. They need a solution built on top of the RESTFul service delivered on the previous exercise. If you used the quickstart, by now you should have a microservice that relies on in-memory persistence with MicroStream. We will now add another option of persistence layer to this service, allowing it to persist data on MongoDB . Goals About the service: You should adapt an existing application, the acme-store-rest application. It uses Microprofile 3.3 + Helidon and MicroStream for persistence. The service handles Product , and provides RESTFul operations for it: List all products: GET \"/products/\" Find a product by ID: GET \"/products/{productName}\" Delete a product: DELETE \"/products/{productName}\" Update a product: PUT \"/products/{productName}\" Insert a product: POST \"/products/{productName}\" The APIs are documented with the Eclipse Microprofile-Open-API ; It's persistence layer relies on MicroStream for performant in-memory persistence capabilities. Goals: Add the support for persistence with JNoSQL for MongoDB; Change as minimum code as possible; Test the application; How to get started The database This exercise requires a MongoDB instance. To facilitate you can use Docker. If you don't have Docker installer yet, you can get it at: https://www.docker.com/ Running MongoDB with Docker: docker run -d --name mongodb-instance -p 27017 :27017 mongo The project You can use the delivered service you finished on the lab Golden APIs for ACME Store . If you prefer, you can also start from this quickstart application. It's similar to a resulting application from the previous lab with extra instructions on what the required tasks: https://github.com/architects4j/helidon-microstream-training-labs-foundation/tree/main/acme-store-rest-nosql To start the application, you can build, package and run it as usual. Implementing the solution See below a general guidance on how you can add NoSQL persistence to this service: Dependencies : Add the Jakarta NoSQL dependencies to pom.xml : <dependency> <groupId> org.eclipse.jnosql.mapping </groupId> <artifactId> mapping-document </artifactId> <version> 1.0.0-b4 </version> </dependency> <dependency> <groupId> org.eclipse.jnosql.communication </groupId> <artifactId> mongodb-driver </artifactId> <version> 1.0.0-b4 </version> </dependency> Database configurations : Add the MongoDB configurations to microprofile-config.properties : # MongoDB Configs document = document document.database = restaurant document.settings.jakarta.nosql.host = localhost:27017 document.provider = org.eclipse.jnosql.communication.mongodb.document.MongoDBDocumentConfiguration Entity configurations : Configure the Product as an entity bean: Add the @jakarta.nosql.mapping.Entity declaration; Add an empty constructor method; g3. Annotate the attributes with adequate column configurations. Use @Id and @Column . Remember, the attributes can no longer be final. The document manager bean: In the package org.a4j.product.infra create a new class DocumentManagerProducer : package org.a4j.product.infra ; //TODO: Set this bean as ApplicationScope class DocumentManagerProducer { //TODO: Use CDI to inject this bean //TODO: Obtain the `document` value configured in microprofile-config.properties. Use @ConfigProperty. private DocumentCollectionManager manager ; // TODO: Configure as a producer with @Produces public DocumentCollectionManager getManager () { return manager ; } public void destroy ( @Disposes DocumentCollectionManager manager ) { manager . close (); } } Creating a new repository : Add a new ProductRepository interface. It should extend the Repository interface: extends Repository < Product , String > Adjusting the resource class implementation : In the ProductResource , let's change the persistence layer. Replace the existing repository based on Inventory with our new one ProductResource . //**Before:** private Inventory repository ; //**After:** @Inject private ProductRepository repository ; the following injection method as we're already injecting in the attribute level: @Inject ProductResource ( Inventory repository ) { this . repository = repository ; } Adding a new method to the repository: : At this point, you will notice the code doesn't compile since the method findAll does not exist in the repository. Currently, (v1.0.0-b4) the jakarta. nosql.mapping.Repository does not offer a findAll out-of-the-box. It does offer save , deleteById , findById , existsById and count , therefore, the only method you need to att to the ProductRepository interface to deliver the existing endpoints is the getAll method. In the ProductRepository , add the method signature. Example: List < Product > findAll (); Testing the service By default it will run on port 8081, as configured in the microprofile-config.properties . Validate your APIs documentation with OpenAPI UI at: http://localhost:8081/openapi-ui/ Check the service implementation with the following request examples: Insert a new product curl --location --request POST 'http://localhost:8081/products' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store cold and hot liquids.\", \"quantity\": \"2\"}' List all products curl --location --request GET 'http://localhost:8081/products' Search a product by ID (name) curl --location --request GET 'http://localhost:8081/products/bottle' Update a product using its ID (name) curl --location --request POST 'http://localhost:8081/products/bottle' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store ONLY cold liquids.\", \"quantity\": \"2\"}' Delete a product by ID (name) curl --location --request DELETE 'http://localhost:8081/products/bottle' If you can successfully execute the above items, it means you acomplished all this challenge goals! Congratulations! You've finished your task for Acme Store! You have easily modified an existing project by taking advantadge of a well-defined persistence layer. You have used JNoSQL to allow this service to persist its data using MongoDB. Well done!","title":"NoSQL persistence on Java services"},{"location":"02_nosql/#nosql-persistence-on-java-services","text":"---- wip: update references to team In this exercise you can validate and practice your knowledge of the following concepts: Java microservice implementation with Helidon; Dev experience when using NoSQL databases with Java; Jakarta NoSQL; Implicit and constant usage of CDI; Getting familiar with the use case and the exercise goals described next is highly recommended, as a detailed step-by-step guide is not provided. Friendly advice : consider leveraging this opportunity to upskill by making the best use of your knowledge and research skills to code the solution without replicating the provided solution.","title":"NoSQL persistence on Java services"},{"location":"02_nosql/#scenario","text":"Acme Store contacted you to ask for advise about NoSQL databases usage in MicroProfile-based services. They need a solution built on top of the RESTFul service delivered on the previous exercise. If you used the quickstart, by now you should have a microservice that relies on in-memory persistence with MicroStream. We will now add another option of persistence layer to this service, allowing it to persist data on MongoDB .","title":"Scenario"},{"location":"02_nosql/#goals","text":"About the service: You should adapt an existing application, the acme-store-rest application. It uses Microprofile 3.3 + Helidon and MicroStream for persistence. The service handles Product , and provides RESTFul operations for it: List all products: GET \"/products/\" Find a product by ID: GET \"/products/{productName}\" Delete a product: DELETE \"/products/{productName}\" Update a product: PUT \"/products/{productName}\" Insert a product: POST \"/products/{productName}\" The APIs are documented with the Eclipse Microprofile-Open-API ; It's persistence layer relies on MicroStream for performant in-memory persistence capabilities. Goals: Add the support for persistence with JNoSQL for MongoDB; Change as minimum code as possible; Test the application;","title":"Goals"},{"location":"02_nosql/#how-to-get-started","text":"","title":"How to get started"},{"location":"02_nosql/#the-database","text":"This exercise requires a MongoDB instance. To facilitate you can use Docker. If you don't have Docker installer yet, you can get it at: https://www.docker.com/ Running MongoDB with Docker: docker run -d --name mongodb-instance -p 27017 :27017 mongo","title":"The database"},{"location":"02_nosql/#the-project","text":"You can use the delivered service you finished on the lab Golden APIs for ACME Store . If you prefer, you can also start from this quickstart application. It's similar to a resulting application from the previous lab with extra instructions on what the required tasks: https://github.com/architects4j/helidon-microstream-training-labs-foundation/tree/main/acme-store-rest-nosql To start the application, you can build, package and run it as usual.","title":"The project"},{"location":"02_nosql/#implementing-the-solution","text":"See below a general guidance on how you can add NoSQL persistence to this service: Dependencies : Add the Jakarta NoSQL dependencies to pom.xml : <dependency> <groupId> org.eclipse.jnosql.mapping </groupId> <artifactId> mapping-document </artifactId> <version> 1.0.0-b4 </version> </dependency> <dependency> <groupId> org.eclipse.jnosql.communication </groupId> <artifactId> mongodb-driver </artifactId> <version> 1.0.0-b4 </version> </dependency> Database configurations : Add the MongoDB configurations to microprofile-config.properties : # MongoDB Configs document = document document.database = restaurant document.settings.jakarta.nosql.host = localhost:27017 document.provider = org.eclipse.jnosql.communication.mongodb.document.MongoDBDocumentConfiguration Entity configurations : Configure the Product as an entity bean: Add the @jakarta.nosql.mapping.Entity declaration; Add an empty constructor method; g3. Annotate the attributes with adequate column configurations. Use @Id and @Column . Remember, the attributes can no longer be final. The document manager bean: In the package org.a4j.product.infra create a new class DocumentManagerProducer : package org.a4j.product.infra ; //TODO: Set this bean as ApplicationScope class DocumentManagerProducer { //TODO: Use CDI to inject this bean //TODO: Obtain the `document` value configured in microprofile-config.properties. Use @ConfigProperty. private DocumentCollectionManager manager ; // TODO: Configure as a producer with @Produces public DocumentCollectionManager getManager () { return manager ; } public void destroy ( @Disposes DocumentCollectionManager manager ) { manager . close (); } } Creating a new repository : Add a new ProductRepository interface. It should extend the Repository interface: extends Repository < Product , String > Adjusting the resource class implementation : In the ProductResource , let's change the persistence layer. Replace the existing repository based on Inventory with our new one ProductResource . //**Before:** private Inventory repository ; //**After:** @Inject private ProductRepository repository ; the following injection method as we're already injecting in the attribute level: @Inject ProductResource ( Inventory repository ) { this . repository = repository ; } Adding a new method to the repository: : At this point, you will notice the code doesn't compile since the method findAll does not exist in the repository. Currently, (v1.0.0-b4) the jakarta. nosql.mapping.Repository does not offer a findAll out-of-the-box. It does offer save , deleteById , findById , existsById and count , therefore, the only method you need to att to the ProductRepository interface to deliver the existing endpoints is the getAll method. In the ProductRepository , add the method signature. Example: List < Product > findAll ();","title":"Implementing the solution"},{"location":"02_nosql/#testing-the-service","text":"By default it will run on port 8081, as configured in the microprofile-config.properties . Validate your APIs documentation with OpenAPI UI at: http://localhost:8081/openapi-ui/ Check the service implementation with the following request examples: Insert a new product curl --location --request POST 'http://localhost:8081/products' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store cold and hot liquids.\", \"quantity\": \"2\"}' List all products curl --location --request GET 'http://localhost:8081/products' Search a product by ID (name) curl --location --request GET 'http://localhost:8081/products/bottle' Update a product using its ID (name) curl --location --request POST 'http://localhost:8081/products/bottle' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store ONLY cold liquids.\", \"quantity\": \"2\"}' Delete a product by ID (name) curl --location --request DELETE 'http://localhost:8081/products/bottle' If you can successfully execute the above items, it means you acomplished all this challenge goals! Congratulations! You've finished your task for Acme Store! You have easily modified an existing project by taking advantadge of a well-defined persistence layer. You have used JNoSQL to allow this service to persist its data using MongoDB. Well done!","title":"Testing the service"},{"location":"more/architects4j/","text":"Architects4J We are tech experts who believe open source and collaborative communities are the way to go. We'll be happy to connect with you through our social media, let's connect! Karina Varela Otavio Santana","title":"Architects4J"},{"location":"more/architects4j/#architects4j","text":"We are tech experts who believe open source and collaborative communities are the way to go. We'll be happy to connect with you through our social media, let's connect! Karina Varela Otavio Santana","title":"Architects4J"},{"location":"more/learn_more/","text":"The microservices used in this workshop were generated using MicroProfile starter. If you want to create a new MicroProfile project, do the following: Let's create a new project using MP Starter page. Access the page https://start.microprofile.io/ . Use the following the data and click on download. You will get a zip file with an automatically generated project for you to get started. Method Description groupId org.a4j artifactId hello-helidon MicroProfile Version 3.3 Build Tool Maven MicroProfile Runtime Helidon Using Helidon CLI [Optional] You can use Helidon CLI for executing tasks like creating new projects and using a feature called \"Developer Loop\". The Developer Loop allows you to leverage hot reload features while coding your helidon services. Using a terminal, access your project's folder hello-helidon . Run the app using the dev loop with: helidon dev After the tool finishes downloading the artifacts, you should be able to see something like: | downloading artifacts | building | build completed ( 1 .9 seconds ) | hello-helidon starting ... 2022 .05.27 22 :59:32 INFO io.helidon.common.HelidonFeatures !thread!: Helidon MP 2 .4.1 features: [ CDI, Config, Fault Tolerance, Health, JAX-RS, Metrics, Open API, REST Client, Security, Server, Tracing ] Alert Sometimes the dev loop might not work on the first initialization of helidon dev. To avoid issues, you can stop the service with ctrl+c (or cmd+c) and start it again with helidon dev . Open the service in your browser: http://localhost:8080/data/hello On your IDE, open the class org.a4j.hello.helidon.HelloController Change the endpoint path to devloop and the string returned by the method sayHello to \"Hello Dev Loop!\" Back in your browser, check your changes reflected at http://localhost:8080/data/devloop Additional information When you are you GraalVM, you can compile your helidon services using Ahead of Time compilation. AoT is a strategy to have the compilation processing during build time, allowing you to create native executable files with fast startup time. For more information check the Helidon docs for Helidon SE GraalVM native image .","title":"Learn more"},{"location":"more/learn_more/#using-helidon-cli-optional","text":"You can use Helidon CLI for executing tasks like creating new projects and using a feature called \"Developer Loop\". The Developer Loop allows you to leverage hot reload features while coding your helidon services. Using a terminal, access your project's folder hello-helidon . Run the app using the dev loop with: helidon dev After the tool finishes downloading the artifacts, you should be able to see something like: | downloading artifacts | building | build completed ( 1 .9 seconds ) | hello-helidon starting ... 2022 .05.27 22 :59:32 INFO io.helidon.common.HelidonFeatures !thread!: Helidon MP 2 .4.1 features: [ CDI, Config, Fault Tolerance, Health, JAX-RS, Metrics, Open API, REST Client, Security, Server, Tracing ] Alert Sometimes the dev loop might not work on the first initialization of helidon dev. To avoid issues, you can stop the service with ctrl+c (or cmd+c) and start it again with helidon dev . Open the service in your browser: http://localhost:8080/data/hello On your IDE, open the class org.a4j.hello.helidon.HelloController Change the endpoint path to devloop and the string returned by the method sayHello to \"Hello Dev Loop!\" Back in your browser, check your changes reflected at http://localhost:8080/data/devloop","title":"Using Helidon CLI [Optional]"},{"location":"more/learn_more/#additional-information","text":"When you are you GraalVM, you can compile your helidon services using Ahead of Time compilation. AoT is a strategy to have the compilation processing during build time, allowing you to create native executable files with fast startup time. For more information check the Helidon docs for Helidon SE GraalVM native image .","title":"Additional information"}]}